<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Make Functions That Can Recurse Infinitely • trampoline</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="bootstrap-toc.css">
<script src="bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="pkgdown.js"></script><meta property="og:title" content="Make Functions That Can Recurse Infinitely">
<meta property="og:description" content="Implements a trampoline algorithm for R that lets users write recursive functions
    that get around Rs stack call limitations, enabling theoretically infinite recursion. The
    algorithm is based around generator function as implemented in the coro package, and is
    based almost completely on the trampoline module from Python [https://gitlab.com/ferreum/trampoline].">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-home">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="index.html">trampoline</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="articles/tampolining.html">Trampolining in R</a>
    </li>
  </ul>
</li>
<li>
  <a href="news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="contents col-md-9">

<div id="trampoline" class="section level1">
<div class="page-header"><h1 class="hasAnchor">
<a href="#trampoline" class="anchor"></a>trampoline</h1></div>
<!-- badges: start -->

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="https://img.shields.io/badge/lifecycle-experimental-orange.svg" alt="Lifecycle: experimental"></a> <!-- badges: end --></p>
<p>The goal of trampoline is to …</p>
<div id="installation" class="section level2">
<h2 class="hasAnchor">
<a href="#installation" class="anchor"></a>Installation</h2>
<p>You can install the development version from <a href="https://github.com/">GitHub</a> with:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># install.packages("devtools")</span>
<span class="fu">devtools</span><span class="fu">::</span><span class="fu"><a href="https://devtools.r-lib.org//reference/remote-reexports.html">install_github</a></span><span class="op">(</span><span class="st">"rdinnager/trampoline"</span><span class="op">)</span></code></pre></div>
<p>This package and this vignette are heavily inspired by the <code>trampoline</code> package in Python (<a href="https://gitlab.com/ferreum/trampoline" class="uri">https://gitlab.com/ferreum/trampoline</a>). In fact, this package is more or less a straight port of that package to R, and this vignette uses all the same examples from the Python <code>trampoline</code> readme, so I thought I would acknowledge that first. For more interesting discussion on trampolining, what it is, what it is good for, etc. please read this <a href="https://tailrecursion.com/wondr/posts/tail-recursion-in-r.html">post</a> by Alan Dipert for discussion specific to R, and this more general <a href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/">post</a> by Eli Bendersky that also goes into a number of related programming concepts and is a really interesting read (though it is focused on Python and Clojure).</p>
</div>
</div>
<div id="what-is-trampolining" class="section level1">
<h1 class="hasAnchor">
<a href="#what-is-trampolining" class="anchor"></a>What is Trampolining?</h1>
<p>In brief, trampolining is a method of doing recursive programming that let’s you theoretically recurse infinitely. Why can’t you do this normally? Well, languages that allow recursive programming, that is, functions that can call themselves, such as R, usually have what is called a ‘call stack’. A call stack keeps tracks of which calls must be resolved before other calls can be executed. In a deeply recursive function, this call stack gets very large, and most programming languages have a limit to how large it can get, including R. We can demonstrate this by creating a very simple recursive function and then running it very deeply.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">print_numbers</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">n</span> <span class="op">&gt;=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
    <span class="fu">print_numbers</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>This trivial function prints numbers from 1 to <code>n</code> by calling itself to print the previous number. The numbers are printed in correct order because the function recurses all the way until <code>n</code> is less than one before continuing, then each recursive call returns to the previous call in reverse order. Let’s try it.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">print_numbers</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; [1] 4</span>
<span class="co">#&gt; [1] 5</span></code></pre></div>
<p>Now, if we increase <code>n</code> to a very large number, we can easily ‘blow up’ the call stack.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">print_numbers</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span>
<span class="co">#&gt; Error: evaluation nested too deeply: infinite recursion / options(expressions=)?</span></code></pre></div>
<p>Trampolining is a way to get around this limit by avoiding using the call stack. The <code>trampoline</code> package implements a simple general trick that theoretically works on any recursive algorithm, which takes advantage of ‘generator’ functions. Now, this didn’t use to be possible in R, because R does not have a native ‘generator’ concept. However, R now does have ‘generators’, thanks to the <a href="https://github.com/r-lib/coro">coro</a> package. You don’t actually need to know anything about ‘generators’ to use <code>trampoline</code>, however, if you are curious and would like to know more, the <a href="https://github.com/r-lib/coro">documentation</a> of <a href="https://github.com/r-lib/coro">coro</a> provides an excellent introduction. Here is the <code>trampoline</code> version of the <code>print_numbers()</code> example. Instead of a function, we create a generator (using <code><a href="https://rdrr.io/pkg/coro/man/generator.html">coro::generator()</a></code>), and then we wrap any recursive calls with the <code>yield()</code> function (this causes the generator to return the argument to <code>yield()</code> to the calling function and pause execution, which drives the recursion). In practice, all we need to remember is to add <code>yield()</code> around our recursive calls. This is the <code>trampoline</code> version:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">trampoline</span><span class="op">)</span>
<span class="co">## generator version</span>

<span class="va">print_numbers</span> <span class="op">&lt;-</span> <span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coro/man/generator.html">generator</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">n</span> <span class="op">&gt;=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
    <span class="fu">yield</span><span class="op">(</span><span class="fu">print_numbers</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span>
  <span class="op">}</span>
<span class="op">}</span><span class="op">)</span>

<span class="va">catch</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/capture.output.html">capture.output</a></span><span class="op">(</span><span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">print_numbers</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="co">## capture output to prevent flooding document with numbers</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">catch</span><span class="op">)</span>
<span class="co">#&gt; [1] "[1] 1" "[1] 2" "[1] 3" "[1] 4" "[1] 5" "[1] 6"</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">catch</span><span class="op">)</span>
<span class="co">#&gt; [1] "[1] 9995"  "[1] 9996"  "[1] 9997"  "[1] 9998"  "[1] 9999"  "[1] 10000"</span></code></pre></div>
<p><code>trampoline</code> also works with recursive function that return a value at the end. To return a final value you just need to wrap the return value with the <code><a href="reference/trm_return.html">trm_return()</a></code> function. This flags to <code>trampoline</code> that this should be returned from the final recursion of the function. Here is an example of a recursive function to calculate and return a factorial:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">factorial</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">n</span> <span class="op">&lt;=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
  <span class="op">}</span>
  <span class="va">val</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Special.html">factorial</a></span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">val</span> <span class="op">*</span> <span class="va">n</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Running this function will exhaust the call stack in as little as 5000 recursions:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Special.html">factorial</a></span><span class="op">(</span><span class="fl">5000</span><span class="op">)</span>
<span class="co">#&gt; Error: evaluation nested too deeply: infinite recursion / options(expressions=)?</span></code></pre></div>
<p>The <code><a href="reference/trampoline.html">trampoline()</a></code> version runs fine, and shows us that the factorial of 5000 is far too large to be represented as an integer in R (resulting in <code>Inf</code>).</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">factorial1</span> <span class="op">&lt;-</span> <span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coro/man/generator.html">generator</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">n</span> <span class="op">&lt;=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="reference/trm_return.html">trm_return</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>
  <span class="op">}</span>
  <span class="va">val</span> <span class="op">&lt;-</span> <span class="fu">yield</span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">val</span> <span class="op">*</span> <span class="va">n</span><span class="op">)</span>
<span class="op">}</span>
<span class="op">)</span>

<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">5000</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] Inf</span></code></pre></div>
<p>With the standard <code>trampoline</code> approach, generator functions spawn generator functions, and each generator is stored in a list internally. All must exist simultaneously, which means that memory can be exhausted in very deep recursions (but typically we have much more RAM available than what is provided in the call stack – in case you are wondering why the call stack is so limited, <a href="https://softwareengineering.stackexchange.com/questions/330626/why-does-the-call-stack-have-a-static-maximum-size">here</a> is one stackexchange question related to that). This approach is very flexible and allows pretty much arbitrary recursive functions where all we have to do is wrap our recursive call in <code>yield()</code>, which makes our function a generator. However, in some cases our recursive functions can be rewritten in a form that allows for a more memory efficient approach. These are know as tail call recursions – their important characteristic is that the recursive call comes as the very last operation in the function. If so, this makes the function a type of simple continuation which can be easily transformed into a standard loop under the hood. <code>trampoline</code> supports tail call recursion by providing a function <code><a href="reference/trm_tailcall.html">trm_tailcall()</a></code> that you can wrap your recursive call in, and which let’s <code>trampoline</code> know that it can take advantage of this more efficient form (additionally for tail call recursions we do not need to call <code>yield()</code> though it will not hurt to do so). For example, the above <code>factorial</code> recursion function is not a tail call recursion because the last operation is the multiplication by <code>n</code>, rather than the recursive call. However, this function can be transformed into a tail call recursion with the help of an additional argument:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">factorial2</span> <span class="op">&lt;-</span> <span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coro/man/generator.html">generator</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">x</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/force.html">force</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="co">## necessary thanks to R's lazy evaluation</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">n</span> <span class="op">&lt;=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">{</span>
    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="reference/trm_return.html">trm_return</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>
  <span class="op">}</span>
  <span class="va">val</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/trm_tailcall.html">trm_tailcall</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span>, <span class="va">x</span> <span class="op">*</span> <span class="va">n</span><span class="op">)</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">val</span><span class="op">)</span>
<span class="op">}</span><span class="op">)</span>

<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">5000</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] Inf</span></code></pre></div>
<p>Note the use of <code><a href="https://rdrr.io/r/base/force.html">force(x)</a></code>. This is required to work around R’s default lazy evaluation, which means an argument is not evaluated until it is used. <code><a href="https://rdrr.io/r/base/force.html">force(x)</a></code> makes sure <code>x</code> is evaluated before it is passed to the next recursion. Without this, it would not be evaluated until the very end of the recursion sequence when it is returned. This has the side effect of requiring R to maintain a call stack to keep track of the environment where <code>x</code> was created, and this causes a stack overflow. If you get an error saying the call stack is exhausted when using <code><a href="reference/trampoline.html">trampoline()</a></code>, lazy evaluation is usually the culprit. Experimenting with forcing different arguments will generally resolve it. To be safe you can simply force all arguments if you wish (note you do not have to use <code><a href="https://rdrr.io/r/base/force.html">force()</a></code>, you only have to use the argument somehow before it is passed to the next function – just putting <code>n; x</code> as the first line of the above function would work, though it is less clear what the purpose is, which is why <code><a href="https://rdrr.io/r/base/force.html">force()</a></code> exists).</p>
<p>Just to show that these all return the same result, we can run them with smaller <code>n</code> where the regular recursive version will work.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R">
<span class="fu"><a href="https://rdrr.io/r/base/Special.html">factorial</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>
<span class="co">#&gt; [1] 3628800</span>
<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 3628800</span>
<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 3628800</span></code></pre></div>
<p>The second version using the tail call should use much less memory than the no tail call version. We can see that using the <code><a href="https://rdrr.io/pkg/bench/man/mark.html">bench::mark()</a></code> function.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bench_res</span> <span class="op">&lt;-</span> <span class="fu">bench</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/bench/man/mark.html">mark</a></span><span class="op">(</span><span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">2000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">2000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">5000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">5000</span><span class="op">)</span><span class="op">)</span>,
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial1</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span><span class="op">)</span>, 
                         <span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">factorial2</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span><span class="op">)</span>,
                         check <span class="op">=</span> <span class="cn">FALSE</span>, iterations <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>
<span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span>

<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">bench_res</span><span class="op">$</span><span class="va">mem_alloc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="cn">FALSE</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">2000</span>, <span class="fl">5000</span>, <span class="fl">10000</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, col <span class="op">=</span> <span class="st">"red"</span>, 
     xlab <span class="op">=</span> <span class="st">"n"</span>, ylab <span class="op">=</span> <span class="st">"Bytes Allocated"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">bench_res</span><span class="op">$</span><span class="va">mem_alloc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="cn">TRUE</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">2000</span>, <span class="fl">5000</span>, <span class="fl">10000</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"right"</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"No Tail Call"</span>, <span class="st">"Tail Call"</span><span class="op">)</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p><img src="reference/figures/README-benchmark-1.png" width="100%"></p>
<p>We can also see that the tail call version is slightly faster:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">bench_res</span><span class="op">$</span><span class="va">total_time</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="cn">FALSE</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">2000</span>, <span class="fl">5000</span>, <span class="fl">10000</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, col <span class="op">=</span> <span class="st">"red"</span>, 
     xlab <span class="op">=</span> <span class="st">"n"</span>, ylab <span class="op">=</span> <span class="st">"Total Time"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">bench_res</span><span class="op">$</span><span class="va">total_time</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="cn">TRUE</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">2000</span>, <span class="fl">5000</span>, <span class="fl">10000</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"l"</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"right"</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"No Tail Call"</span>, <span class="st">"Tail Call"</span><span class="op">)</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p><img src="reference/figures/README-benchmark2-1.png" width="100%"></p>
<p>Note that <code>trampoline</code> adds overhead that may result in a slower performance. However, the overhead is fairly small. It is noticeable for extremely fast computations like the ones done here, but for more complicated computations, the overhead should represent a small proportion of the total execution time. Another performance related note is that <code><a href="reference/trampoline.html">trampoline()</a></code> internally disables R’s Just-In-Time (JIT) compilation (sometimes referred to as the ‘byte’ compiler). By default R will attempt to precompile functions before the first or second time they are called (depending on their ‘size’). Since generator functions are created anew in each recursion, and they are called twice overall, this mean each one will be precompiled by R, which adds enormous overhead, especially given we know they will not be called a third time in most cases. So disabling JIT makes <code><a href="reference/trampoline.html">trampoline()</a></code> faster. On the other hand it means that any function you write that gets called for the first time inside the <code><a href="reference/trampoline.html">trampoline()</a></code> call will not be compiled. In some cases this means you might not be able to take advantage of compilation for a function that could benefit from it. If so, you can get around this issue by calling your function once or twice before running <code><a href="reference/trampoline.html">trampoline()</a></code> which will cause R to compile it (assuming you are using default JIT settings, accessible with the <code><a href="https://rdrr.io/r/compiler/compile.html">compiler::enableJIT()</a></code> function). Alternatively you could explicitly precompile your function yourself using the <code><a href="https://rdrr.io/r/compiler/compile.html">compiler::cmpfun()</a></code> function.</p>
<p>In this vignette we have used some very basic recursive functions to demonstrate how <code>trampoline</code> works, but it’s true power only becomes apparent in more complicated situations. If your recursion is simple enough to be converted to a tail call recursion, then existing methods might be enough for you (e.g. this <a href="https://tailrecursion.com/wondr/posts/tail-recursion-in-r.html">post</a> presents an R function by Jim Hester that allows tail call recursion). <code>trampoline</code> however, let’s you run pretty much any type of recursive function without having to think too much about it. For example, mutually recursive functions work out of the box, like this classic trivial example:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">even</span> <span class="op">&lt;-</span> <span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coro/man/generator.html">generator</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span> <span class="op">(</span><span class="va">n</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="fu"><a href="reference/trm_return.html">trm_return</a></span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span> <span class="kw">else</span> <span class="fu">yield</span><span class="op">(</span><span class="fu">odd</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span><span class="op">)</span>

<span class="va">odd</span> <span class="op">&lt;-</span> <span class="fu">coro</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coro/man/generator.html">generator</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw">if</span> <span class="op">(</span><span class="va">n</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="fu"><a href="reference/trm_return.html">trm_return</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="kw">else</span> <span class="fu">yield</span><span class="op">(</span><span class="fu">even</span><span class="op">(</span><span class="va">n</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span><span class="op">)</span>

<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">even</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">even</span><span class="op">(</span><span class="fl">10001</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] FALSE</span>

<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">odd</span><span class="op">(</span><span class="fl">10000</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] FALSE</span>
<span class="fu"><a href="reference/trampoline.html">trampoline</a></span><span class="op">(</span><span class="fu">odd</span><span class="op">(</span><span class="fl">10001</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>An example where <code>trampoline</code> can really shine is in branching recursive functions, such as functions that traverse trees of various kinds, where we don’t want to worry about hitting the call stack limit with large trees. One natural way of specifying these generally cannot be converted to tail call form easily because the recursive function is called multiple times within its body, and so they cannot all be in tail position. For some examples of these more complicated branching recursive functions, see the vignette “Traversing Trees with Trampoline”.</p>
</div>

  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <div class="license">
<h2>License</h2>
<ul class="list-unstyled">
<li><a href="LICENSE.html">Full license</a></li>
<li><small><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file <a href="LICENSE-text.html">LICENSE</a></small></li>
</ul>
</div>
<div class="developers">
<h2>Developers</h2>
<ul class="list-unstyled">
<li>Russell Dinnage <br><small class="roles"> Author, maintainer, copyright holder </small> <a href="https://orcid.org/0000-0003-0846-2819" target="orcid.widget" aria-label="ORCID"><span class="fab fa-orcid orcid" aria-hidden="true"></span></a> </li>
</ul>
</div>

  <div class="dev-status">
<h2>Dev status</h2>
<ul class="list-unstyled">
<li><a href="https://github.com/rdinnager/trampoline/actions"><img src="https://github.com/rdinnager/trampoline/workflows/R-CMD-check/badge.svg" alt="R-CMD-check"></a></li>
</ul>
</div>
</div>
</div>


      <footer><div class="copyright">
  <p>Developed by Russell Dinnage.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
